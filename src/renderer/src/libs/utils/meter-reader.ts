import { Schemas } from '@shared/types'
import { addHours } from 'date-fns'
import { useMemo } from 'react'

type AppRecordedData = Schemas['AppRecordedData']

export function meterReadStatusData({ data }: { data: AppRecordedData }) {
  if (!data) return undefined

  const item = data[0]
  const electricityEndpoint = item.endpointsRes.find((e: any) => e.endpoint === 'electricity')

  return {
    kwh: electricityEndpoint?.response?.data?.kwh,
    dateTime: addHours(item.dateTime, 2)
  }
}

// Used with getAppRecordedData from useMrPingPingService() // Has historic data
export function formatDMeterReadHistoricData({
  data,
  interval
}: {
  data: { appName: string; appStatus: any[] }[]
  interval: number
}) {
  if (!data?.length) return undefined

  const item = data[0]

  // Filter valid temperature readings
  const validKwhs = item?.appStatus
    ?.map((s: any) => {
      const tempEndpoint = s.endpointsRes.find((e: any) => e.endpoint === 'electricity')
      return tempEndpoint?.response?.code === 200
        ? { kwh: tempEndpoint.response.data.kwh, date: addHours(s.date, 2) }
        : null
    })
    .filter(Boolean)
    .slice(-interval) // take last <number> valid readings

  if (!validKwhs?.length) return undefined

  // Temperature trend
  const latestKwh = validKwhs.at(-1)
  const firstTemp = validKwhs[0]
  const kwhTrend =
    latestKwh?.kwh > firstTemp?.kwh ? 'up' : latestKwh?.kwh < firstTemp?.kwh ? 'down' : 'stable'

  return {
    kwh: latestKwh?.kwh,
    kwhTrend: kwhTrend,
    kwhHistory: validKwhs,
    dateTime: addHours(latestKwh?.date, 2)
  }
}

// Generated by chatGPT:
// type Reading = { kwh: number; date: string } // incoming shape
type Reading = {
  kwh: any
  date: any
} | null // incoming shape
type CleanReading = { kwh: number; date: string; t: number } // t = timestamp ms
export type HourlyUsage = {
  from: string
  to: string
  hours: number
  used: number // kWh used between from -> to
  kwhPerHour: number
  removed?: boolean
}
export type CalcKwhAnalyticsType = {
  remainingKwh: number
  burnRateKwhPerHour: number
  projectedDailyUse: number
  hoursLeft: number
  daysLeft: number
  cleanedHistory: CleanReading[]
  hourlyUsage: HourlyUsage[]
  anomalies: { index: number; reading: Reading; reason: string }[]
  thresholdKwh: number
  medianTypicalUsage: number
}

export function calcKwhAnalytics({
  kwh,
  kwhHistory
}: {
  kwh: number // current remaining kwh (same as last history item ideally)
  kwhHistory: Reading[] | undefined
}): CalcKwhAnalyticsType {
  // return useMemo(() => {
  if (!Array.isArray(kwhHistory) || kwhHistory.length === 0) {
    return {
      remainingKwh: kwh ?? 0,
      cleanedHistory: [] as CleanReading[],
      hourlyUsage: [] as HourlyUsage[],
      burnRateKwhPerHour: 0,
      projectedDailyUse: 0,
      hoursLeft: Infinity,
      daysLeft: Infinity,
      thresholdKwh: 0,
      medianTypicalUsage: 0,
      anomalies: [] as { index: number; reading: Reading; reason: string }[]
    }
  }

  // --- Normalize & sort by date ascending (oldest -> newest)
  const normalized: CleanReading[] = kwhHistory
    ?.map((r) => ({
      kwh: Number(r?.kwh),
      date: r?.date,
      t: new Date(r?.date).getTime()
    }))
    .filter((r) => !Number.isNaN(r.kwh) && !Number.isNaN(r.t))
    .sort((a, b) => a.t - b.t)

  // --- First pass: compute diffs and candidate usages (prev - curr)
  type Diff = { idx: number; used: number; hours: number; rawDelta: number }
  const diffs: Diff[] = []
  for (let i = 1; i < normalized.length; i++) {
    const prev = normalized[i - 1]
    const cur = normalized[i]
    const used = prev.kwh - cur.kwh
    const hours = Math.max((cur.t - prev.t) / (1000 * 60 * 60), 1e-6)
    diffs.push({ idx: i, used, hours, rawDelta: used })
  }

  // --- Determine a robust threshold for "huge spike"
  // Use median of positive usages as typical usage. If median is tiny, fall back to 0.5 kWh.
  const positiveUsages = diffs?.map((d) => d.used).filter((u) => u > 0)
  function median(arr: number[]) {
    if (!arr.length) return 0
    const s = arr.slice().sort((a, b) => a - b)
    const m = Math.floor(s.length / 2)
    return s.length % 2 === 1 ? s[m] : (s[m - 1] + s[m]) / 2
  }
  const med = median(positiveUsages)
  const baseTypical = Math.max(med, 0.2) // if median zero, assume tiny usage
  // threshold: anything > max(10 kWh, baseTypical * 7) will be considered a spike
  const thresholdKwh = Math.max(10, baseTypical * 7)

  // --- Identify anomalies
  const anomalies: { index: number; reading: Reading; reason: string }[] = []
  // We'll build cleaned list by rejecting anomalous readings
  const cleaned: CleanReading[] = [normalized[0]] // always keep first
  for (let i = 1; i < normalized.length; i++) {
    const prevAccepted = cleaned[cleaned.length - 1]
    const cur = normalized[i]
    const used = prevAccepted.kwh - cur.kwh
    // If the reading increased (used < 0) -> suspicious (meter should go down on prepaid)
    if (used < -0.01) {
      anomalies.push({
        index: i,
        reading: { kwh: cur.kwh, date: cur.date },
        reason: `reading increased relative to last accepted (${prevAccepted.kwh} â†’ ${cur.kwh})`
      })
      // skip (do NOT accept this reading)
      continue
    }
    // If the implied usage is crazy-large
    if (used > thresholdKwh) {
      anomalies.push({
        index: i,
        reading: { kwh: cur.kwh, date: cur.date },
        reason: `huge drop (${used.toFixed(2)} kWh) exceeds threshold ${thresholdKwh.toFixed(2)} kWh`
      })
      // skip
      continue
    }
    // Otherwise accept
    cleaned.push(cur)
  }

  // If cleaning removed everything except first, fallback to last normalized as accepted (avoid empty)
  if (cleaned.length === 1 && normalized.length > 1) {
    // try a softer pass: accept any non-increasing readings (used >= -0.01) even if big
    cleaned.length = 0
    cleaned.push(normalized[0])
    for (let i = 1; i < normalized.length; i++) {
      const prevAccepted = cleaned[cleaned.length - 1]
      const cur = normalized[i]
      const used = prevAccepted.kwh - cur.kwh
      if (used < -0.01) {
        anomalies.push({
          index: i,
          reading: { kwh: cur.kwh, date: cur.date },
          reason: `reading increased (soft-pass)`
        })
        continue
      }
      cleaned.push(cur)
    }
  }

  // --- Build hourly usage array from cleaned data
  const hourlyUsage: HourlyUsage[] = []
  for (let i = 1; i < cleaned.length; i++) {
    const prev = cleaned[i - 1]
    const cur = cleaned[i]
    const used = prev.kwh - cur.kwh
    const hours = Math.max((cur.t - prev.t) / (1000 * 60 * 60), 1e-6)
    const kwhPerHour = used / hours
    hourlyUsage.push({
      from: prev.date,
      to: cur.date,
      hours,
      used,
      kwhPerHour
    })
  }

  // --- Compute burn rate (kWh/hour) using a weighted strategy:
  // Use the last up-to-5 valid intervals and compute a time-weighted average
  const recent = hourlyUsage.slice(-6)
  let burnRateKwhPerHour = 0
  if (recent.length > 0) {
    let totalHours = 0
    let totalKwh = 0
    for (const r of recent) {
      totalHours += r.hours
      totalKwh += r.used
    }
    burnRateKwhPerHour = totalKwh / Math.max(totalHours, 1e-6)
  }

  // If burnRate is zero (no change), try global average
  if (burnRateKwhPerHour <= 1e-9 && hourlyUsage.length > 0) {
    const totHours = hourlyUsage.reduce((s, r) => s + r.hours, 0)
    const totKwh = hourlyUsage.reduce((s, r) => s + r.used, 0)
    burnRateKwhPerHour = totKwh / Math.max(totHours, 1e-6)
  }

  // Protect against negative/NaN
  if (!isFinite(burnRateKwhPerHour) || burnRateKwhPerHour < 0) burnRateKwhPerHour = 0

  const projectedDailyUse = burnRateKwhPerHour * 24
  const remainingKwh = typeof kwh === 'number' ? kwh : (cleaned[cleaned.length - 1]?.kwh ?? 0)

  const hoursLeft = burnRateKwhPerHour > 1e-9 ? remainingKwh / burnRateKwhPerHour : Infinity
  const daysLeft = hoursLeft === Infinity ? Infinity : hoursLeft / 24

  // Also prepare a compact anomaly summary (dedup indices that might refer to same timestamp)
  const anomalySummary = anomalies?.map((a) => ({
    index: a.index,
    reading: a.reading,
    reason: a.reason
  }))

  return {
    remainingKwh: Number(remainingKwh.toFixed(3)),
    burnRateKwhPerHour: Number(burnRateKwhPerHour.toFixed(6)),
    projectedDailyUse: Number(projectedDailyUse.toFixed(3)),
    hoursLeft: Number(isFinite(hoursLeft) ? hoursLeft.toFixed(2) : hoursLeft),
    daysLeft: Number(isFinite(daysLeft) ? daysLeft.toFixed(2) : daysLeft),
    cleanedHistory: cleaned,
    hourlyUsage,
    anomalies: anomalySummary as { index: number; reading: Reading; reason: string }[],
    thresholdKwh: Number(thresholdKwh.toFixed(3)),
    medianTypicalUsage: Number(baseTypical.toFixed(3))
  }
}
